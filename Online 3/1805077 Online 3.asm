.MODEL SMALL
.STACK 100H

.DATA
ARRAY DW 100 DUP(?)
N DB ?
ARRAY_SIZE DW ?
PROMPT1 DB "ENTER SIZE OF ARRAY: ",13,10,"$"
PROMPT2 DB 13,10,10,"ENTER ELEMENTS: ",13,10,"$"
PROMPT_PRINT DB 13,10,"SORTED ARRAY: $"
PROMPT3 DB 13,10,10,"ENTER SEARCH KEY: ",13,10,"$"
NL DB 13,10,"$"
SUCCESS DB "FOUND AT $"
FAILURE DB "NOT FOUND$"
INV_SIZE DB 13,10,"INVALID INPUT$"
FLAG DB 0
TEMP DW ?
NUMBER_STRING DB "00000$"
MIN_INDEX DW ?

.CODE
MAIN PROC
    MOV AX, @DATA
    MOV DS, AX

    MOV DX, OFFSET PROMPT1
    MOV AH, 9
    INT 21H
    
;; ENTRY
    MOV DX, 0

INPUT_LOOP_N:
    MOV AH, 1
    INT 21H
    CMP AL, 13
    JE BREAK_1
    CMP AL, 45
    JE INVALID_SIZE

    SUB AL, '0'     ; AL HAS THE INPUT AND WE SUBTRACT 0 FROM IT 
    MOV N, AL
    MOV AX, 10      ; MULTIPLIES WITH THIS REGISTER
    MUL DX          ; ONLY ONE PARAMETER, PRODUCT GOES TO AX
    MOV DX, AX      ; GET IT BACK TO DX   
    ADD DL, N 
    JMP INPUT_LOOP_N 
BREAK_1:
    MOV ARRAY_SIZE, DX  ; NOW SIZE HAS THE ARRAY SIZE
    CMP ARRAY_SIZE, 0
    JLE INVALID_SIZE
    
    MOV DX, OFFSET PROMPT2
    MOV AH, 9
    INT 21H
    
    MOV CX, ARRAY_SIZE  ; LOOP ITERATOR
    LEA SI, ARRAY       ; SETTING ARRAY ADDRESS
    MOV DX, 0
INPUT_LOOP_ARRAY:
    INPUT_LOOP_ENTRY:
        MOV AH, 1           
        INT 21H             ; INPUT THE NUMBER 
        CMP AL, 13          
        JE BREAK_2          ; IF ENTER IS PRESSED PUT THE ACCUMULATED INTEGER IN THE ARRAY
        CMP AL, 45          ; CHECK IF - IS INPUTTED
        JNE POSITIVE_ENTRY  ; IF NOT, INPUT THE NUMBER
        MOV FLAG, 1         ; IF - THEN CHANGE FLAG TO 1 WHICH WILL NEGATE THE INPUTTED NUMBER AFTER PRESSING ENTER
        JMP INPUT_LOOP_ENTRY
    POSITIVE_ENTRY:    
        SUB AL, '0' 
        MOV N, AL
        MOV AX, 10 
        MUL DX 
        MOV DX, AX    
        ADD DL, N 
        JMP INPUT_LOOP_ENTRY 
    BREAK_2:
        CMP FLAG, 1
        JNE POSITIVE
        NEG DX
    POSITIVE:
        MOV [SI], DX        ; SETTING INT VALUE IN ARRAY
        ADD SI, 2
        MOV DX, OFFSET NL   ; NEWLINE
        MOV AH, 9
        INT 21H
        MOV DX, 0
        MOV FLAG, 0           ; RE-INIT DX AND FLAG FOR INPUT
    LOOP INPUT_LOOP_ARRAY



;;  SORT   
    LEA SI, ARRAY
    MOV CX, ARRAY_SIZE


SELECTION_SORT:
    PUSH CX             ;;;;;;;
    ;DEC CX
    MOV BX, ARRAY_SIZE
    SUB BX, CX    ; BX I
    MOV DX, BX    ; DX J
    ;INC DX        ; J = I+1
    MOV MIN_INDEX, BX
    PUSH BX                  ;;;;;
    INNER_LOOP_SEL:
        INC DX
        MOV CX, ARRAY_SIZE
        DEC CX
        CMP DX, CX
        JNLE INNER_BREAK
        
        MOV BX, DX
        ADD BX, BX
        MOV CX, SI[BX]  ;ARR[J]
        
        MOV BX, MIN_INDEX
        ADD BX, BX
        MOV AX, SI[BX]  ; ARR[MIN_INDEX]
        
        CMP CX, AX
        JNLE INNER_LOOP_SEL
        MOV MIN_INDEX, DX
        
        JMP INNER_LOOP_SEL 
    INNER_BREAK:
    ; SWAPPING  
    MOV BX, MIN_INDEX
    ADD BX, BX
    MOV CX, SI[BX]
    
    POP BX
    ADD BX, BX
    MOV AX, SI[BX]
    
    MOV SI[BX], CX
    MOV BX, MIN_INDEX
    ADD BX, BX
    MOV SI[BX], AX
    
    MOV CX, ARRAY_SIZE
    LEA DI, ARRAY
    XOR BX, BX
PRINT_ARRAY_LOOP:
    PUSH CX
    ; MOV FLAG, 0
    MOV AX, [DI]
    CALL PRINT
    MOV AH ,2
    MOV DL, ' '
    INT 21H 
    ADD DI, 2
    POP CX
    LOOP PRINT_ARRAY_LOOP
    
    POP CX
    CMP CX, 1
    JE BREAK_SORT
    JMP SELECTION_SORT
BREAK_SORT:    
    
        















EXIT:    
    MOV AH, 4CH
    INT 21H
INVALID_SIZE:
    MOV DX, OFFSET INV_SIZE
    MOV AH, 9
    INT 21H
    MOV AH, 4CH
    INT 21H
MAIN ENDP

PRINT PROC                      ; PRINTS A WORD INTEGER IN AX
    
    LEA SI, NUMBER_STRING       ; IS "00000"
    ADD SI, 5                   ; START FROM ONE'S DIGIT
    
    CMP AX, 0
    JNL PRINT_LOOP
    MOV FLAG, 1
    NEG AX
    
    PRINT_LOOP:
        DEC SI
        
        MOV DX, 0               ; DX:AX = 0000:AX
        MOV CX, 10
        DIV CX
        
        ADD DL, '0'
        MOV [SI], DL
        
        CMP AX, 0
        JNE PRINT_LOOP
    
    CMP FLAG, 0
    JNG NOT_NEGATIVE
    MOV AH, 2
    MOV DL, 45
    INT 21H
    MOV FLAG, 0
NOT_NEGATIVE:
    MOV DX, SI
    MOV AH, 9
    INT 21H
    
    
    RET
PRINT ENDP
END MAIN
